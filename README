λ-calculus, but slow

syntax
------

- a λ abstraction:

    λarg.body

  or

    \arg.body

- a function application

  (func arg)

- a symbolic value

  x

- environment binding of a λ-abstraction or a value to a name

    name ← value

  or

    name <- value

A program is a mixture of all of those. The value bound to the name `output' is reduced and printed to the standard output.
You can use the -v (verbose) flag to show the number of passes used.
You can use the -vv (very verbose) flag to show every single step of reduction.
Files in lib/ are compiled into the `eru' binary, and can be later included in your program with

  .include basename.l

So, lib/cons.l would be included with

  .include cons.l

The .include directive will try to include a file from your computer, when a given filename is not compiled in.

examples
--------

  1. bazinga

    bazinga ← λx.λy.x
    output ← ((bazinga mrow) boo)

  1.1 usage

    $ ./eru -v bazinga.l
    Reduced in 5 passes, 4 substitutions. 144 bytes allocated
    mrow

  2. self-referencing factorial with Y combinator

    succ ← λn.λf.λx.(f ((n f) x))
    pred ← λn.λf.λx.(((n λg.λh.(h (g f))) λ_.x) I)

    0 ← λf.λx.x
    1 ← (succ 0)
    4 ← (succ (succ (succ 1)))
    zero? ← λn.((n λx.false) true)

    I ← λx.x
    true ← λx.λy.x
    false ← λx.λy.y

    * ← λm.λn.((m (+ n)) 0)
    + ← λm.λn.((m succ) n)

    fac' ← λf.λn.(((zero? n) 1) ((* n) (f (pred n))))
    Y ← λg.(λx.(g (x x)) λx.(g (x x)))

    output ← ((Y fac') 4)

  2.1 usage

    $ ./eru -v Y.l
    Reduced in 290 passes, 10256 substitutions. 83394360 bytes allocated
    λf.λx.(f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f x))))))))))))))))))))))))

  3. almost a iota w/ a stupid hack to overcome the naivity of the reducer

    .include cons.l
    .include comb.l
    .include math.l

    _rev ← λrev.λl.(((null? (cdr l)) ((cons (car l)) nil)) ((append' (rev (cdr l))) (car l)))
    rev ← (Y _rev)

    _riota ← λriota.λx.(((zero? x) nil) ((cons x) (riota (pred x))))
    riota ← (Y _riota)

    _append' ← λappend.λl.λel.(((null? l) ((cons el) nil)) ((cons (car l)) ((append (cdr l)) el)))
    append' ← (Y _append')

    lst ← #(riota 3)
    ;;    ^- here's the hack
    ;;    it evaluates the riota in-place there when parsing the source
    ;;    because (rev)-ing it makes the reducer go boom

    output ← (rev lst)

  3.1 usage

    $ ./eru iota.l
    λf.((f λf.λx.(f x)) λf.((f λf.λx.(f (f x))) λf.((f λf.λx.(f (f (f x)))) λx.λx.λy.x)))

obligatory self-deprecation & warnings
--------------------------------------

- the parser sucks. i'll fix it one day.

a ← b
; this is also okay
a <- b
; this is also also okay
a arrow b
; but this is not
a  ← b
; ^- this whitespace is the reason
; can you spot the difference? the parser can
(this is not a curried application over `this'. it's a syntax error. please beware)
((((while this) is) perfectly) okay)
((i'm so) sorry)